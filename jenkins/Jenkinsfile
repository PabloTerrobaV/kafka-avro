pipeline {
    agent any

    // Definici√≥n de variables de entorno, que se usar√°n en los comandos
    environment {
        // URL del Schema Registry (accesible desde Jenkins en la red de Docker)
        SCHEMA_REGISTRY_URL = 'http://schema-registry:8081'
        // El subject que se usar√° para consultar la configuraci√≥n de compatibilidad en Schema Registry
        SUBJECT_NAME = 'orders-value'
        // URL del repositorio Git donde se encuentra el esquema actualizado
        GITHUB_REPO_URL = 'https://github.com/PabloTerrobaV/kafka-avro.git'
        // Rama del repositorio
        GITHUB_BRANCH = 'main'
        // Ruta relativa del esquema dentro del proyecto (nuevo esquema que se obtendr√° del repo)
        SCHEMA_PATH = 'common/src/main/avro/Order.avsc'
    }

    stages {
        // Stage padre: filtra la ejecuci√≥n de todo el pipeline
        stage('Activar pipeline solo si hay cambios en el esquema') {
            // Este bloque 'when' hace que todo el bloque interno solo se ejecute si hay cambios en el directorio de esquemas Avro
            when {
                changeset "common/src/main/avro/**"
            }
            steps {
                // Mensaje informativo en la consola para indicar que el pipeline se activa
                echo "Se han detectado cambios en 'common/src/main/avro/'. El pipeline continuar√°."
            }

            // Bloque de stages internos: cada uno representa un paso clave del proceso de gesti√≥n de esquemas
            stages {

                // ******** Stage 1: Descarga del esquema antiguo ********
                stage('Descargar versi√≥n antigua del esquema') {
                    steps {
                        echo 'Descargando versi√≥n antigua del esquema desde Schema Registry...'
                        // Descarga el esquema Avro actualmente registrado en el Schema Registry, para comparar con el nuevo
                        sh """
                        curl -v ${SCHEMA_REGISTRY_URL}/subjects/${SUBJECT_NAME}/versions/latest | jq -r .schema > old_schema.avsc || {
                            echo "Error al descargar el esquema antiguo"
                            exit 1
                        }
                        """
                    }
                }

                // ******** Stage 2: Obtener nueva versi√≥n del esquema ********
                stage('Obtener nueva versi√≥n del esquema') {
                    steps {
                        echo 'Descargando nueva versi√≥n del esquema desde GitHub...'
                        // Realiza checkout del repositorio para obtener el archivo del esquema actualizado
                        checkout([
                            $class: 'GitSCM',
                            branches: [[name: "${GITHUB_BRANCH}"]],
                            userRemoteConfigs: [[url: "${GITHUB_REPO_URL}"]]
                        ])
                        // Copia el archivo actualizado del esquema a un archivo temporal para su procesamiento
                        sh "cp ${SCHEMA_PATH} new_schema.avsc || { echo 'Error al copiar el nuevo esquema'; exit 1; }"
                    }
                }

                // ******** Stage 3: Inspecci√≥n de esquemas ********
                stage('Inspeccionar esquemas') {
                    steps {
                        // Verifica que ambos archivos (antiguo y nuevo) existan y muestra su contenido por consola
                        sh '''
                        echo "üîç Verificando existencia y contenido de los archivos AVSC..."

                        if [ -f old_schema.avsc ]; then
                          echo "‚úÖ old_schema.avsc existe:"
                          cat old_schema.avsc
                        else
                          echo "‚ùå old_schema.avsc no se encuentra"
                        fi

                        if [ -f new_schema.avsc ]; then
                          echo "‚úÖ new_schema.avsc existe:"
                          cat new_schema.avsc
                        else
                          echo "‚ùå new_schema.avsc no se encuentra"
                        fi
                        '''
                    }
                }

                // ******** Stage 4: Comparaci√≥n de esquemas ********
                stage('Comparar esquemas y detectar cambios') {
                    steps {
                        echo 'Comparando esquemas y detectando cambios...'
                        // Depuraci√≥n: muestra los archivos disponibles y el contenido de los esquemas antes de la comparaci√≥n
                        sh '''
                        echo "[DEBUG] Archivos disponibles en scripts/"
                        ls -l scripts

                        echo "[DEBUG] Contenido de old_schema.avsc:"
                        cat old_schema.avsc || echo "No se encontr√≥ old_schema.avsc"

                        echo "[DEBUG] Contenido de new_schema.avsc:"
                        cat new_schema.avsc || echo "No se encontr√≥ new_schema.avsc"

                        echo "[DEBUG] Ejecutando script de comparaci√≥n..."
                        python3 scripts/compare_schemas.py old_schema.avsc new_schema.avsc > schema_diff.txt || {
                            echo "[ERROR] Error durante la comparaci√≥n"
                            cat schema_diff.txt || echo "schema_diff.txt no se cre√≥"
                            exit 1
                        }

                        echo "[DEBUG] Contenido de schema_diff.txt:"
                        cat schema_diff.txt
                        '''
                        // Lee el resultado de la comparaci√≥n y lo muestra en consola
                        script {
                            def changes = readFile('schema_diff.txt')
                            echo "Cambios detectados:\n${changes}"
                        }
                    }
                }

                // ******** Stage 5: Validaci√≥n de compatibilidad ********
                stage('Validar compatibilidad del esquema') {
                    steps {
                        echo 'Validando compatibilidad del esquema...'
                        // Ejecuta un script Python que valida la compatibilidad entre el esquema antiguo y el nuevo,
                        // seg√∫n la configuraci√≥n del Schema Registry. Si no es compatible, el pipeline falla.
                        sh '''
                        python3 scripts/validate_compatibility.py old_schema.avsc new_schema.avsc || {
                            echo "[ERROR] La validaci√≥n de compatibilidad ha fallado"
                            exit 1
                        }
                        '''
                    }
                }

                // ******** Stage 6: A√±adir metadato de tiempo ********
                stage('A√±adir metadato con fecha y hora al esquema para evitar duplicidades') {
                    steps {
                        echo 'Ajustando el nuevo esquema para forzar el registro de una nueva versi√≥n...'
                        // A√±ade un campo "doc" con la fecha y hora al esquema para evitar duplicidades en el registro
                        sh '''
                            TIMESTAMP=$(date "+%Y-%m-%d %H:%M:%S")
                            sed -i "s/\\"namespace\\" *: *\\"com.example.kafka\\"/\\"namespace\\": \\"com.example.kafka\\", \\"doc\\": \\"Actualizado el $TIMESTAMP\\"/" new_schema.avsc
                            echo "Contenido de new_schema.avsc modificado:"
                            cat new_schema.avsc
                        '''
                    }
                }

                // ******** Stage 7: Registro en Schema Registry ********
                stage('Registrar esquema en Schema Registry') {
                    steps {
                        echo 'Registrando nuevo esquema en Schema Registry...'
                        // Convierte el esquema en JSON y lo registra en el Schema Registry usando curl
                        script {
                            def response = sh(
                                script: '''
                                echo "[DEBUG] Generando payload JSON con jq..."
                                jq -Rs '{schema: .}' new_schema.avsc > payload.json

                                echo "[DEBUG] Payload de registro:"
                                cat payload.json

                                echo "[DEBUG] Ejecutando registro con curl..."
                                curl -s -X POST -H "Content-Type: application/vnd.schemaregistry.v1+json" \\
                                     --data @payload.json \\
                                     ${SCHEMA_REGISTRY_URL}/subjects/${SUBJECT_NAME}/versions
                                ''',
                                returnStdout: true
                            ).trim()

                            echo "Respuesta del registro: ${response}"

                            // Aqu√≠ podr√≠as procesar la respuesta para validar la versi√≥n registrada, si lo necesitas
                        }
                    }
                }

                // ******** Stage 8: Notificaci√≥n a grupo prioritario ********
                stage('Notificaci√≥n a grupo prioritario seg√∫n compatibilidad') {
                    steps {
                        echo 'Obteniendo configuraci√≥n de compatibilidad desde Schema Registry...'
                        script {
                            // Consulta el nivel de compatibilidad configurado para el subject en el Schema Registry
                            def output = sh(
                                script: "curl -s ${SCHEMA_REGISTRY_URL}/config/${SUBJECT_NAME} | jq -r '.compatibilityLevel'",
                                returnStdout: true
                            ).trim()
                            echo "Compatibilidad configurada: ${output}"

                            // Determina y notifica el grupo prioritario seg√∫n la compatibilidad
                            if (output.startsWith("BACKWARD")) {
                                echo "üîî Notificando a consumidores (prioritarios) para que actualicen primero..."
                            } else if (output.startsWith("FORWARD")) {
                                echo "üîî Notificando a productores (prioritarios) para que actualicen primero..."
                            } else if (output.startsWith("FULL")) {
                                echo "üîî Notificando a ambos grupos para actualizaci√≥n simult√°nea..."
                            } else {
                                echo "‚ö†Ô∏è Compatibilidad no reconocida. Notificando a todos por precauci√≥n."
                            }
                        }
                    }
                }

                // ******** Stage 9: Verificaci√≥n de servicios ********
                stage('Verificar actualizaci√≥n de servicios') {
                    steps {
                        // Llama a otro job de Jenkins para verificar si los servicios (productores/consumidores) se han actualizado correctamente
                        build job: 'Validaci√≥n de las versiones en productores-consumidores', wait: false
                    }
                }
            } // Fin del bloque de stages internos
        } // Fin del stage padre
    } // Fin del bloque stages global

    post {
        success {
            echo "‚úÖ Proceso completado exitosamente. Los esquemas fueron descargados, comparados, validados y se verific√≥ la actualizaci√≥n del grupo prioritario."
        }
        failure {
            echo "‚ùå Proceso fallido. Revisar los logs para m√°s detalles."
        }
    }
}